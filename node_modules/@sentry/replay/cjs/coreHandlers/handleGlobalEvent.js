var {
  _optionalChain
} = require('@sentry/utils/cjs/buildPolyfills');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const constants = require('../constants.js');
const isRrwebError = require('../util/isRrwebError.js');

/**
 * Returns a listener to be added to `addGlobalEventProcessor(listener)`.
 */
function handleGlobalEventListener(replay) {
  return (event) => {
    // Do not apply replayId to the root event
    if (event.type === constants.REPLAY_EVENT_NAME) {
      // Replays have separate set of breadcrumbs, do not include breadcrumbs
      // from core SDK
      delete event.breadcrumbs;
      return event;
    }

    // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb
    // As there can be a bunch of stuff going wrong in internals there, that we don't want to bubble up to users
    if (isRrwebError.isRrwebError(event) && !_optionalChain([replay, 'access', _ => _.getOptions, 'call', _2 => _2(), 'access', _3 => _3._experiments, 'optionalAccess', _4 => _4.captureExceptions])) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log('[Replay] Ignoring error from rrweb internals', event);
      return null;
    }

    // Only tag transactions with replayId if not waiting for an error
    // @ts-ignore private
    if (!event.type || replay.recordingMode === 'session') {
      event.tags = { ...event.tags, replayId: _optionalChain([replay, 'access', _5 => _5.session, 'optionalAccess', _6 => _6.id]) };
    }

    // Collect traceIds in _context regardless of `recordingMode` - if it's true,
    // _context gets cleared on every checkout
    if (event.type === 'transaction' && event.contexts && event.contexts.trace && event.contexts.trace.trace_id) {
      replay.getContext().traceIds.add(event.contexts.trace.trace_id );
      return event;
    }

    // no event type means error
    if (!event.type) {
      replay.getContext().errorIds.add(event.event_id );
    }

    const exc = _optionalChain([event, 'access', _7 => _7.exception, 'optionalAccess', _8 => _8.values, 'optionalAccess', _9 => _9[0]]);
    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && _optionalChain([replay, 'access', _10 => _10.getOptions, 'call', _11 => _11(), 'access', _12 => _12._experiments, 'optionalAccess', _13 => _13.traceInternals])) {
      addInternalBreadcrumb({
        message: `Tagging event (${event.event_id}) - ${event.message} - ${_optionalChain([exc, 'optionalAccess', _14 => _14.type]) || 'Unknown'}: ${
          _optionalChain([exc, 'optionalAccess', _15 => _15.value]) || 'n/a'
        }`,
      });
    }

    // Need to be very careful that this does not cause an infinite loop
    if (
      replay.recordingMode === 'error' &&
      event.exception &&
      event.message !== constants.UNABLE_TO_SEND_REPLAY // ignore this error because otherwise we could loop indefinitely with trying to capture replay and failing
    ) {
      setTimeout(async () => {
        // Allow flush to complete before resuming as a session recording, otherwise
        // the checkout from `startRecording` may be included in the payload.
        // Prefer to keep the error replay as a separate (and smaller) segment
        // than the session replay.
        await replay.flushImmediate();

        if (replay.stopRecording()) {
          // Reset all "capture on error" configuration before
          // starting a new recording
          replay.recordingMode = 'session';
          replay.startRecording();
        }
      });
    }

    return event;
  };
}

function addInternalBreadcrumb(arg) {
  const { category, level, message, ...rest } = arg;

  core.addBreadcrumb({
    category: category || 'console',
    level: level || 'debug',
    message: `[debug]: ${message}`,
    ...rest,
  });
}

exports.handleGlobalEventListener = handleGlobalEventListener;
//# sourceMappingURL=handleGlobalEvent.js.map
