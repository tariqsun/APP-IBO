{"version":3,"file":"dedupePerformanceEntries.js","sources":["../../../../src/util/dedupePerformanceEntries.ts"],"sourcesContent":["import type { PerformanceNavigationTiming, PerformancePaintTiming } from '../types';\n\nconst NAVIGATION_ENTRY_KEYS: Array<keyof PerformanceNavigationTiming> = [\n  'name',\n  'type',\n  'startTime',\n  'transferSize',\n  'duration',\n];\n\nfunction isNavigationEntryEqual(a: PerformanceNavigationTiming) {\n  return function (b: PerformanceNavigationTiming) {\n    return NAVIGATION_ENTRY_KEYS.every(key => a[key] === b[key]);\n  };\n}\n\n/**\n * There are some difficulties diagnosing why there are duplicate navigation\n * entries. We've witnessed several intermittent results:\n * - duplicate entries have duration = 0\n * - duplicate entries are the same object reference\n * - none of the above\n *\n * Compare the values of several keys to determine if the entries are duplicates or not.\n */\n// TODO (high-prio): Figure out wth is returned here\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function dedupePerformanceEntries(\n  currentList: PerformanceEntryList,\n  newList: PerformanceEntryList,\n): PerformanceEntryList {\n  // Partition `currentList` into 3 different lists based on entryType\n  const [existingNavigationEntries, existingLcpEntries, existingEntries] = currentList.reduce(\n    (acc: [PerformanceNavigationTiming[], PerformancePaintTiming[], PerformanceEntryList], entry) => {\n      if (entry.entryType === 'navigation') {\n        acc[0].push(entry as PerformanceNavigationTiming);\n      } else if (entry.entryType === 'largest-contentful-paint') {\n        acc[1].push(entry as PerformancePaintTiming);\n      } else {\n        acc[2].push(entry);\n      }\n      return acc;\n    },\n    [[], [], []],\n  );\n\n  const newEntries: PerformanceEntryList = [];\n  const newNavigationEntries: PerformanceNavigationTiming[] = [];\n  let newLcpEntry: PerformancePaintTiming | undefined = existingLcpEntries.length\n    ? existingLcpEntries[existingLcpEntries.length - 1] // Take the last element as list is sorted\n    : undefined;\n\n  newList.forEach(entry => {\n    if (entry.entryType === 'largest-contentful-paint') {\n      // We want the latest LCP event only\n      if (!newLcpEntry || newLcpEntry.startTime < entry.startTime) {\n        newLcpEntry = entry;\n      }\n      return;\n    }\n\n    if (entry.entryType === 'navigation') {\n      const navigationEntry = entry as PerformanceNavigationTiming;\n\n      // Check if the navigation entry is contained in currentList or newList\n      if (\n        // Ignore any navigation entries with duration 0, as they are likely duplicates\n        entry.duration > 0 &&\n        // Ensure new entry does not already exist in existing entries\n        !existingNavigationEntries.find(isNavigationEntryEqual(navigationEntry)) &&\n        // Ensure new entry does not already exist in new list of navigation entries\n        !newNavigationEntries.find(isNavigationEntryEqual(navigationEntry))\n      ) {\n        newNavigationEntries.push(navigationEntry);\n      }\n\n      // Otherwise this navigation entry is considered a duplicate and is thrown away\n      return;\n    }\n\n    newEntries.push(entry);\n  });\n\n  // Re-combine and sort by startTime\n  return [\n    ...(newLcpEntry ? [newLcpEntry] : []),\n    ...existingNavigationEntries,\n    ...existingEntries,\n    ...newEntries,\n    ...newNavigationEntries,\n  ].sort((a, b) => a.startTime - b.startTime);\n}\n"],"names":[],"mappings":"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"}